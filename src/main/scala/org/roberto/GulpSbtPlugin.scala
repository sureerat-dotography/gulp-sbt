//------------------------------------------------------------------------------
// Copyright (c) 2014 Ross Bayer
//------------------------------------------------------------------------------

package org.rbayer

import sbt._
import Keys._

/**
 * sbt plugin that provides integration with
 * <a href="http://gulpjs.com/">Gulp.js</a> that allows execution of Gulp.js
 * builds from within sbt.
 *
 * In addition to a basic <code>gulp</code> command that allows arbitrary
 * execution of gulp commands from the sbt console, this plugin also provides
 * tasks for executing one or more gulp tasks as part of a the compile
 * and test phases (with the ability to extend other configurations as well).
 *
 * @author Ross Bayer
 */
object GulpSbtPlugin extends Plugin {

  /**
   * Settings and tasks for the gulp-sbt plugin
   */
  object GulpKeys {

    val gulpPath = settingKey[String]("The path to the gulp executable. By " +
      "default, the plugin will look for `gulp` in the $PATH.")

    val gulpNodePath = settingKey[String]("The path to the node.js " +
      "executable.  By default, the plugin will look for `node` in the $PATH.")

    val gulpNpmPath = settingKey[String]("The path to the npm executable. " +
      "By default, the plugin will look for `npm` in the $PATH.")

    val gulpTasks = settingKey[Seq[String]]("Sequence of gulp tasks to " +
      "execute as part of the `gulp` task for a particular configuration.  " +
      "For instance, for `Compile`, this could be `jshint` and `build`")

    val gulpResourcesDirectory = settingKey[Option[File]]("Directory " +
      "where files generated by the gulp process are located.  This " +
      "directory, if set, will be added to the managed resources of the " +
      "project.")

    val gulpResourcesClasspath = settingKey[File]("Classpath to use " +
      "in final jar for accessing resource files generated by gulp and " +
      "output to the `gulpOutputDirectory`.  This path will be relative to " +
      "the root of the JAR (i.e. `META-INF/resources/...`)")

    val gulpForce = settingKey[Boolean]("If true, the `--force` option " +
      "will be used when executing gulp, thus ignoring failures.")

    lazy val gulp = taskKey[Seq[File]]("Executes gulp tasks defined by the " +
      "`gulpTasks` key.")

    lazy val npmInstall = taskKey[Int]("Executes `npm install ` in the " +
      "project's parent directory if a package.json file is present.")
  }

  import GulpKeys._

  /**
   * Base sequence of settings for sbt for an arbitrary configuration.
   */
  val basePerConfigGulpSettings: Seq[Setting[_]] = Seq(
    gulpTasks := Seq(""),
    gulpForce := false,
    gulp <<= gulpTask,
    gulpResourcesDirectory := None,
    gulpResourcesClasspath := file("META-INF/resources")
  )

  /**
   * Core settings used by all configurations.
   */
  val baseGulpSettings: Seq[Setting[_]] = Seq(
    gulpPath := "gulp",
    gulpNpmPath := "npm",
    gulpNodePath := ""
  )

  /**
   * Sequence of settings to be included in a user's build.sbt file to
   * add gulp support to their build.  This includes defining gulp tasks
   * in the <code>Compile</code> and <code>Test</code> configurations.
   */
  val gulpSettings: Seq[Setting[_]] =
    baseGulpSettings ++
    gulpSettingsIn(Compile, Seq(
      gulpTasks := Seq("build"),
      npmInstall <<= npmInstallTask,
      resourceGenerators in Compile <+= gulpTask,
      (resources in Compile) <<= (resources in Compile) dependsOn (npmInstall in Compile)
    )) ++
    gulpSettingsIn(Test, Seq(
      gulpTasks := Seq("test"),
      (gulp in Test) <<= (gulp in Test) dependsOn (executeTests in Test),
      (test in Test) <<= (test in Test) dependsOn (gulp in Test)
    ))

  override lazy val settings = Seq(
    commands ++= Seq(
      gulpCmd
    )
  )

  /**
   * Implementation of gulp task that will execute one or more tasks defined
   * by the <code>gulpTasks</code> setting via the <code>gulp</code> command.
   */
  lazy val gulpTask: Def.Initialize[Task[Seq[File]]] = Def.task {
    val force = if (gulpForce.value) "--force" else ""
    val log = streams.value.log

    exec(
      gulpNodePath.value,
      gulpPath.value,
      args = Seq(force) ++ gulpTasks.value,
      cwd = thisProject.value.base,
      s = Some(streams.value))

    val gulpOutputDir: Option[File] = gulpResourcesDirectory.value
    gulpOutputDir map processManagedFiles(
      resourceManaged.value,
      gulpResourcesClasspath.value,
      log) getOrElse Seq.empty
  }

  /**
   * Task that will execute <code>npm install</code> in the current working
   * directory.
   */
  lazy val npmInstallTask: Def.Initialize[Task[Int]] = Def.task {
    // Don't execute if no package.json is found in directory
    val cwd = thisProject.value.base
    val pkgFileExists = (cwd / "package.json").exists

    if (pkgFileExists) exec(
      gulpNodePath.value,
      gulpNpmPath.value,
      args = Seq("install"),
      cwd = cwd,
      s = Some(streams.value))
    else 0
  }

  /**
   * Command for executing the <code>gulp</code> command interactively from
   * the sbt console.
   */
  lazy val gulpCmd = Command.single("gulp") { (state, task) =>
    val extracted = Project.extract(state)
    val nodePath = extracted.getOpt(gulpNodePath).get
    val cmd = extracted.getOpt(gulpPath).get

    exec(nodePath, cmd, Seq(task))

    state
  }

  /**
   * Convenience method for including gulp-sbt plugin configuration values
   * with an arbitrary sbt configuration.
   *
   * This method will add the default settings to the configuration, and then
   * allow the user to update the values as they wish.
   *
   * @param c The configuration to add gulp values to.
   * @param overrides Sequence of settings that can be used to override or
   *                  extend the default values provided by the plugin.
   *
   * @return The final sequence of settings in the specified configuration.
   */
  def gulpSettingsIn(c: Configuration, overrides: Seq[Setting[_]] = Seq.empty[Setting[_]]): Seq[Setting[_]] =
    inConfig(c)(basePerConfigGulpSettings ++ overrides)

  /**
   * Executes a node command in an external process.
   *
   * @param nodePath Path to the <code>node</code> executable.
   * @param cmd The command to execute.  This can be either a fully-qualified
   *            filesystem path to the command, or a basename (assumed to be
   *            on the user's $PATH).
   * @param args Sequence of arguments to pass to the command.
   * @param s Optional TaskStreams object used for debug logging.
   *
   * @return The return code from the node process.
   */
  private def exec(
    nodePath: String,
    cmd: String,
    args: Seq[String] = Seq(),
    cwd: File = file("."),
    s: Option[TaskStreams] = None):Int = {

    val fullCmd = (Seq[String](nodePath, cmd) ++ args) filter { _.length > 0 } mkString " "

    s map { _stream =>
      _stream.log.info(s"Executing gulp-sbt command: $fullCmd")
      _stream.log.debug(s"Gulp cwd: $cwd")
    }

    val rc = Process(fullCmd, cwd).!

    if (rc == 0) rc else sys.error(s"Gulp generated non-zero return code: $rc")
  }

  /**
   * Process resource files generated by gulp, copy them to the resourceManaged
   * directory if necessary, and return the sequence of files to be added to
   * the final artifact.
   *
   * @param log Logger to log debug messages to.
   * @param resourceManaged Directory where managed resources are stored.
   * @param classpathTarget Path to copy files to in final Jar classpath.
   * @param outputDir The output directory where gulp generated files.
   *
   * @return Sequence of new files to be managed by the build.
   */
  private def processManagedFiles(
    resourceManaged: File,
    classpathTarget: File,
    log: Logger)
    (outputDir: File): Seq[File] = {

    // Find all generated files based on configured output directory
    val generatedFilesFinder = outputDir * "*" ** "*"
    val generatedFiles: Seq[File] = generatedFilesFinder.get

    generatedFiles foreach { f => log.debug(s"Found gulp-generated file: $f") }

    // If files are not children of the resourcesManaged directory, copy them
    // there.
    val resourceManagedRoot: File = resourceManaged / classpathTarget.getPath
    val filesToCopy: Seq[File] = ((generatedFilesFinder --- (resourceManagedRoot / "*")) filter (_.isFile)).get
    val managedFiles: Seq[File] = filesToCopy map { f =>
      val relPath = IO.relativize(outputDir, f) getOrElse sys.error("Cannot calculate relative path of file")
      resourceManagedRoot / relPath
    }

    IO.copy(filesToCopy zip managedFiles, overwrite = true)

    managedFiles foreach { f => log.debug(s"Copied managed file: $f") }
    managedFiles
  }
}
